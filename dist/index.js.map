{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../../../../usr/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../external node-commonjs \"fs\"","../external node-commonjs \"path\"","../webpack/bootstrap","../webpack/runtime/compat",".././index.js"],"sourcesContent":[null,"module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core');\nconst github = require('@actions/github');\nconst fs = require('fs').promises;\nconst path = require('path');\n\n// Ecosyste.ms API client\nclass EcosystemsClient {\n  constructor() {\n    this.packagesBaseUrl = 'https://packages.ecosyste.ms/api/v1';\n    this.cache = new Map();\n    this.bigTechDomains = [\n      'amazon.com', 'amazon.co.uk',\n      'microsoft.com',\n      'google.com', 'alphabet.com',\n      'meta.com', 'fb.com', 'facebook.com',\n      'openai.com',\n      'netflix.com',\n      'apple.com',\n      'oracle.com',\n      'ibm.com',\n      'salesforce.com',\n      'intel.com',\n      'amd.com'\n    ];\n  }\n\n  async getPackageData(purl) {\n    if (this.cache.has(purl)) {\n      return this.cache.get(purl);\n    }\n\n    try {\n      if (!purl.startsWith('pkg:npm/')) {\n        core.info(`Skipping non-npm package: ${purl}`);\n        return null;\n      }\n\n      const npmPart = purl.substring('pkg:npm/'.length);\n      let packageName;\n      \n      if (npmPart.startsWith('@')) {\n        const match = npmPart.match(/^(@[^/]+\\/[^@]+)(?:@(.+))?$/);\n        if (!match) return null;\n        packageName = match[1];\n      } else {\n        const match = npmPart.match(/^([^@]+)(?:@(.+))?$/);\n        if (!match) return null;\n        packageName = match[1];\n      }\n\n      const encodedName = packageName.replace('@', '%40').replace('/', '%2F');\n      const packageUrl = `${this.packagesBaseUrl}/registries/npmjs.org/packages/${encodedName}`;\n      \n      core.info(`Fetching package: ${packageUrl}`);\n      const packageResponse = await fetch(packageUrl);\n      \n      if (!packageResponse.ok) {\n        core.warning(`Package API failed for ${packageName}: ${packageResponse.status}`);\n        return null;\n      }\n\n      const packageData = await packageResponse.json();\n      \n      await new Promise(resolve => setTimeout(resolve, 100));\n      this.cache.set(purl, packageData);\n      \n      return packageData;\n    } catch (error) {\n      core.warning(`Error fetching ${purl}: ${error.message}`);\n      return null;\n    }\n  }\n\n  hasBigTechBacking(maintainers, repoOwner) {\n    // Check maintainer emails\n    if (maintainers && Array.isArray(maintainers)) {\n      const hasEmailBacking = maintainers.some(m => {\n        if (!m.email) return false;\n        const domain = m.email.split('@')[1]?.toLowerCase();\n        return this.bigTechDomains.includes(domain);\n      });\n      if (hasEmailBacking) return true;\n    }\n    \n    // Check repo owner\n    if (repoOwner) {\n      const ownerLower = repoOwner.toLowerCase();\n      const bigTechOrgs = ['facebook', 'meta', 'google', 'microsoft', 'amazon', 'netflix', 'apple', 'openai', 'oracle', 'ibm', 'salesforce', 'intel', 'amd'];\n      return bigTechOrgs.some(org => ownerLower.includes(org));\n    }\n    \n    return false;\n  }\n\n  async getPackageInfo(purl) {\n    const data = await this.getPackageData(purl);\n    if (!data) return null;\n\n    const repoMeta = data.repo_metadata || {};\n    \n    const info = {\n      name: data.name,\n      dependents_count: data.dependent_packages_count || 0,\n      stars: repoMeta.stargazers_count || 0,\n      age_months: data.created_at ? this.monthsSince(data.created_at) : 0,\n      last_update_months: data.updated_at ? this.monthsSince(data.updated_at) : 0,\n      repository_url: data.repository_url,\n      big_tech_backing: this.hasBigTechBacking(data.maintainers, repoMeta.owner)\n    };\n\n    return info;\n  }\n\n  monthsSince(dateString) {\n    const date = new Date(dateString);\n    const now = new Date();\n    const months = (now.getFullYear() - date.getFullYear()) * 12 + \n                   (now.getMonth() - date.getMonth());\n    return Math.max(0, months);\n  }\n}\n\n// SBOM Parser\nclass SBOMParser {\n  static async parse(filePath) {\n    try {\n      const content = await fs.readFile(filePath, 'utf8');\n      const sbom = JSON.parse(content);\n\n      if (sbom.spdxVersion) {\n        return this.parseSPDX(sbom);\n      } else if (sbom.bomFormat === 'CycloneDX') {\n        return this.parseCycloneDX(sbom);\n      } else {\n        throw new Error('Unsupported SBOM format. Expected SPDX or CycloneDX JSON.');\n      }\n    } catch (error) {\n      core.setFailed(`Failed to parse SBOM: ${error.message}`);\n      throw error;\n    }\n  }\n\n  static parseSPDX(sbom) {\n    const components = [];\n    \n    if (sbom.packages) {\n      for (const pkg of sbom.packages) {\n        // Skip the root package (the project itself)\n        if (pkg.name && (pkg.name.includes('oss-wishlist') || pkg.name.includes('oss-sustainability'))) {\n          continue;\n        }\n        \n        if (pkg.externalRefs) {\n          const purlRef = pkg.externalRefs.find(ref => ref.referenceType === 'purl');\n          if (purlRef) {\n            const purl = purlRef.referenceLocator;\n            // Only include npm packages, skip GitHub Actions and other package types\n            if (purl.startsWith('pkg:npm/') && !purl.includes('actions/') && !purl.includes('anchore/')) {\n              components.push({\n                name: pkg.name,\n                version: pkg.versionInfo,\n                purl: purl,\n                supplier: pkg.supplier,\n                license: pkg.licenseConcluded\n              });\n            }\n          }\n        }\n      }\n    }\n\n    return components;\n  }\n\n  static parseCycloneDX(sbom) {\n    const components = [];\n    \n    if (sbom.components) {\n      for (const component of sbom.components) {\n        // Only include npm packages, skip GitHub Actions and root package\n        if (component.purl && \n            component.purl.startsWith('pkg:npm/') && \n            !component.purl.includes('actions/') && \n            !component.purl.includes('anchore/') &&\n            !component.name.includes('oss-wishlist') &&\n            !component.name.includes('oss-sustainability')) {\n          components.push({\n            name: component.name,\n            version: component.version,\n            purl: component.purl,\n            supplier: component.supplier?.name,\n            license: component.licenses?.[0]?.license?.id\n          });\n        }\n      }\n    }\n\n    return components;\n  }\n}\n\n// Dependency Analyzer\nclass DependencyAnalyzer {\n  constructor(dependencyThreshold) {\n    this.dependencyThreshold = parseInt(dependencyThreshold) || 1000;\n    this.ecosystems = new EcosystemsClient();\n  }\n\n  async analyzeComponents(components) {\n    const results = [];\n\n    core.info(`Analyzing ${components.length} components...`);\n\n    for (const component of components) {\n      if (!component.purl) {\n        core.warning(`Skipping ${component.name}: no PURL available`);\n        continue;\n      }\n\n      core.info(`Analyzing ${component.name}...`);\n      \n      const info = await this.ecosystems.getPackageInfo(component.purl);\n      \n      if (info) {\n        // Only include packages with high dependency counts\n        if (info.dependents_count >= this.dependencyThreshold) {\n          results.push({\n            ...component,\n            ...info\n          });\n        }\n      } else {\n        core.warning(`No data available for ${component.name}, skipping`);\n      }\n    }\n\n    // Sort by dependents count (highest first)\n    results.sort((a, b) => b.dependents_count - a.dependents_count);\n\n    return {\n      packages: results,\n      total_analyzed: components.length,\n      high_dependency_count: results.length\n    };\n  }\n}\n\n// Report Generator\nclass ReportGenerator {\n  static async generateMarkdown(analysis, threshold) {\n    let report = '# OSS Dependency Analysis Report\\n\\n';\n    \n    report += `## Summary\\n\\n`;\n    report += `- **Total Dependencies**: ${analysis.total_analyzed}\\n`;\n    report += `- **High-Usage Dependencies** (${threshold.toLocaleString()}+ dependents): ${analysis.high_dependency_count}\\n`;\n    \n    const withBigTech = analysis.packages.filter(p => p.big_tech_backing).length;\n    const withoutBigTech = analysis.packages.length - withBigTech;\n    \n    report += `- **With Big Tech Backing**: ${withBigTech}\\n`;\n    report += `- **Without Big Tech Backing**: ${withoutBigTech}\\n\\n`;\n\n    if (analysis.packages.length === 0) {\n      report += `No dependencies found with ${threshold.toLocaleString()}+ dependents.\\n\\n`;\n      return report;\n    }\n\n    // Group by Big Tech backing\n    const withBacking = analysis.packages.filter(p => p.big_tech_backing);\n    const withoutBacking = analysis.packages.filter(p => !p.big_tech_backing);\n\n    if (withoutBacking.length > 0) {\n      report += `## ‚ö†Ô∏è High-Usage Dependencies WITHOUT Big Tech Backing\\n\\n`;\n      report += `These packages are widely used but may lack organizational support:\\n\\n`;\n      \n      for (const pkg of withoutBacking) {\n        report += `### ${pkg.name} (v${pkg.version})\\n\\n`;\n        report += `- **Dependents**: ${pkg.dependents_count.toLocaleString()} üì¶\\n`;\n        report += `- **Stars**: ${pkg.stars.toLocaleString()} ‚≠ê\\n`;\n        report += `- **Age**: ${pkg.age_months} months\\n`;\n        report += `- **Last Update**: ${pkg.last_update_months} months ago\\n`;\n        if (pkg.repository_url) {\n          report += `- **Repository**: ${pkg.repository_url}\\n`;\n        }\n        report += `\\n`;\n      }\n    }\n\n    if (withBacking.length > 0) {\n      report += `## ‚úÖ High-Usage Dependencies WITH Big Tech Backing\\n\\n`;\n      \n      for (const pkg of withBacking) {\n        report += `### ${pkg.name} (v${pkg.version})\\n\\n`;\n        report += `- **Dependents**: ${pkg.dependents_count.toLocaleString()} üì¶\\n`;\n        report += `- **Stars**: ${pkg.stars.toLocaleString()} ‚≠ê\\n`;\n        report += `- **Age**: ${pkg.age_months} months\\n`;\n        report += `- **Last Update**: ${pkg.last_update_months} months ago\\n`;\n        if (pkg.repository_url) {\n          report += `- **Repository**: ${pkg.repository_url}\\n`;\n        }\n        report += `\\n`;\n      }\n    }\n\n    report += `---\\n\\n`;\n    report += `*Generated by OSS Wishlist Analyzer*\\n`;\n\n    return report;\n  }\n\n  static async saveReport(report, outputPath) {\n    await fs.writeFile(outputPath, report, 'utf8');\n    core.info(`Report saved to ${outputPath}`);\n  }\n}\n\n// Main action logic\nasync function run() {\n  try {\n    const sbomPath = core.getInput('sbom-path');\n    const token = core.getInput('token');\n    const dependencyThreshold = core.getInput('dependency-threshold') || '1000';\n    const createIssue = core.getInput('create-issue') === 'true';\n    const commentPR = core.getInput('comment-pr') === 'true';\n\n    core.info(`Starting OSS Dependency Analysis...`);\n    core.info(`SBOM Path: ${sbomPath}`);\n    core.info(`Dependency Threshold: ${dependencyThreshold}`);\n\n    const components = await SBOMParser.parse(sbomPath);\n    core.info(`Found ${components.length} components in SBOM`);\n\n    const analyzer = new DependencyAnalyzer(dependencyThreshold);\n    const analysis = await analyzer.analyzeComponents(components);\n\n    const report = await ReportGenerator.generateMarkdown(analysis, parseInt(dependencyThreshold));\n    const reportPath = path.join(process.cwd(), 'oss-wishlist-report.md');\n    await ReportGenerator.saveReport(report, reportPath);\n\n    core.setOutput('high-dependency-count', analysis.high_dependency_count);\n    core.setOutput('without-backing-count', analysis.packages.filter(p => !p.big_tech_backing).length);\n    core.setOutput('report-path', reportPath);\n\n    if (commentPR && github.context.payload.pull_request) {\n      const octokit = github.getOctokit(token);\n      await octokit.rest.issues.createComment({\n        ...github.context.repo,\n        issue_number: github.context.payload.pull_request.number,\n        body: report\n      });\n      core.info('Posted analysis as PR comment');\n    }\n\n    const withoutBacking = analysis.packages.filter(p => !p.big_tech_backing).length;\n    if (createIssue && withoutBacking > 0) {\n      const octokit = github.getOctokit(token);\n      await octokit.rest.issues.create({\n        ...github.context.repo,\n        title: `‚ö†Ô∏è ${withoutBacking} High-Usage Dependencies Without Big Tech Backing`,\n        body: report,\n        labels: ['dependencies', 'sustainability']\n      });\n      core.info('Created issue for dependencies without backing');\n    }\n\n    core.info('‚úÖ Analysis complete!');\n\n  } catch (error) {\n    core.setFailed(error.message);\n  }\n}\n\nrun();"],"names":[],"sourceRoot":""}