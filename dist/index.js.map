{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../../../../../usr/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../external node-commonjs \"fs\"","../external node-commonjs \"path\"","../webpack/bootstrap","../webpack/runtime/compat",".././index.js"],"sourcesContent":[null,"module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core');\nconst github = require('@actions/github');\nconst fs = require('fs').promises;\nconst path = require('path');\n\n// Configuration Constants\nconst CONFIG = {\n  // Configuration Constants\n  API_CONFIGURATION: {\n    BASE_URL: 'https://packages.ecosyste.ms/api/v1',\n    RATE_LIMIT_DELAY_MS: 100,\n  },\n  \n  // Default Thresholds\n  DEFAULT_DEPENDENCY_THRESHOLD: 1000,\n  \n  // Time Constants\n  MONTHS_PER_YEAR: 12,\n  \n  // Output Configuration\n  REPORT_FILENAME: 'oss-wishlist-report.md',\n  \n  // Filtering Patterns\n  EXCLUDED_PACKAGE_PATTERNS: ['actions/', 'anchore/'],\n  EXCLUDED_PROJECT_NAMES: ['oss-wishlist', 'oss-sustainability'],\n  PURL_PREFIX: 'pkg:',\n  \n  // SBOM Format Identifiers\n  SBOM_FORMATS: {\n    SPDX_VERSION_KEY: 'spdxVersion',\n    CYCLONEDX_FORMAT_KEY: 'bomFormat',\n    CYCLONEDX_FORMAT_VALUE: 'CycloneDX'\n  },\n  \n  // PURL Reference Type\n  PURL_REFERENCE_TYPE: 'purl',\n  \n  // GitHub Issue Configuration\n  ISSUE_LABELS: ['dependencies', 'sustainability'],\n  ISSUE_TITLE_PREFIX: '⚠️',\n  \n  // Report Configuration\n  REPORT_TITLE: '# OSS Dependency Wishlist Report',\n  REPORT_SUMMARY_TITLE: '## Summary',\n  REPORT_WITHOUT_BACKING_TITLE: '## ⚠️ Dependencies with Wishlists Needing Support',\n  REPORT_WITHOUT_BACKING_DESCRIPTION: 'These packages have wishlists but may lack organizational support:',\n  REPORT_WITH_BACKING_TITLE: '## ✅ Dependencies with Wishlists and Big Tech Backing',\n  REPORT_FOOTER: '*Generated by OSS Wishlist Analyzer*',\n  \n  // Big Tech Identifiers\n  BIG_TECH_DOMAINS: [\n    'amazon.com', 'amazon.co.uk',\n    'microsoft.com',\n    'google.com', 'alphabet.com',\n    'meta.com', 'fb.com', 'facebook.com',\n    'openai.com',\n    'anthropic.com',\n    'nvidia.com',\n    'netflix.com',\n    'apple.com',\n    'oracle.com',\n    'ibm.com',\n    'salesforce.com',\n    'intel.com',\n    'amd.com'\n  ],\n  \n  BIG_TECH_ORG_NAMES: [\n    'facebook', 'meta', 'google', 'microsoft', 'amazon', \n    'netflix', 'apple', 'openai', 'anthropic', 'nvidia',\n    'oracle', 'ibm', 'salesforce', 'intel', 'amd'\n  ],\n  \n  // Package Registry Mapping\n  REGISTRY_MAP: {\n    'npm': 'npmjs.org',\n    'pypi': 'pypi.org',\n    'cargo': 'crates.io',\n    'maven': 'maven.org',\n    'gem': 'rubygems.org',\n    'golang': 'pkg.go.dev',\n    'nuget': 'nuget.org',\n    'hex': 'hex.pm',\n    'pub': 'pub.dev',\n    'composer': 'packagist.org',\n    'hackage': 'hackage.haskell.org',\n    'cocoapods': 'cocoapods.org',\n    'clojars': 'clojars.org',\n    'cpan': 'metacpan.org',\n    'cran': 'cran.r-project.org',\n    'conda': 'anaconda.org'\n  }\n};\n\n// Ecosyste.ms API client\nclass EcosystemsClient {\n  constructor() {\n    this.packagesBaseUrl = CONFIG.API_CONFIGURATION.BASE_URL;\n    this.cache = new Map();\n    this.bigTechDomains = CONFIG.BIG_TECH_DOMAINS;\n    this.registryMap = CONFIG.REGISTRY_MAP;\n  }\n\n  parsePackageUrl(purl) {\n    // Parse PURL format: pkg:type/namespace/name@version\n    const purlMatch = purl.match(/^pkg:([^/]+)\\/(.+)$/);\n    if (!purlMatch) return null;\n    \n    const type = purlMatch[1];\n    const rest = purlMatch[2];\n    \n    // Get registry name from type\n    const registry = this.registryMap[type];\n    if (!registry) {\n      core.info(`Unsupported package type: ${type}`);\n      return null;\n    }\n    \n    // Extract package name (strip version if present)\n    let packageName;\n    if (rest.includes('@') && !rest.startsWith('@')) {\n      // Format: name@version\n      packageName = rest.split('@')[0];\n    } else if (rest.startsWith('@')) {\n      // Format: @scope/name@version (npm scoped packages)\n      const match = rest.match(/^(@[^@]+)(?:@.+)?$/);\n      packageName = match ? match[1] : rest;\n    } else {\n      // Format: namespace/name@version or name@version\n      packageName = rest.split('@')[0];\n    }\n    \n    return { type, registry, packageName };\n  }\n\n  async getPackageData(purl) {\n    if (this.cache.has(purl)) {\n      return this.cache.get(purl);\n    }\n\n    try {\n      const parsed = this.parsePackageUrl(purl);\n      if (!parsed) return null;\n      \n      const { type, registry, packageName } = parsed;\n      \n      // URL encode the package name\n      const encodedName = encodeURIComponent(packageName);\n      const packageUrl = `${this.packagesBaseUrl}/registries/${registry}/packages/${encodedName}`;\n      \n      core.info(`Fetching ${type} package: ${packageName}`);\n      const packageResponse = await fetch(packageUrl);\n      \n      if (!packageResponse.ok) {\n        core.warning(`Package API failed for ${packageName}: ${packageResponse.status}`);\n        return null;\n      }\n\n      const packageData = await packageResponse.json();\n      \n      await new Promise(resolve => setTimeout(resolve, CONFIG.API_CONFIGURATION.RATE_LIMIT_DELAY_MS));\n      this.cache.set(purl, packageData);\n      \n      return packageData;\n    } catch (error) {\n      core.warning(`Error fetching ${purl}: ${error.message}`);\n      return null;\n    }\n  }\n\n  hasBigTechBacking(maintainers, repoOwner) {\n    // Check maintainer emails\n    if (maintainers && Array.isArray(maintainers)) {\n      const hasEmailBacking = maintainers.some(m => {\n        if (!m.email) return false;\n        const domain = m.email.split('@')[1]?.toLowerCase();\n        return this.bigTechDomains.includes(domain);\n      });\n      if (hasEmailBacking) return true;\n    }\n    \n    // Check repo owner\n    if (repoOwner) {\n      const ownerLower = repoOwner.toLowerCase();\n      return CONFIG.BIG_TECH_ORG_NAMES.some(org => ownerLower.includes(org));\n    }\n    \n    return false;\n  }\n\n  async getPackageInfo(purl) {\n    const data = await this.getPackageData(purl);\n    if (!data) return null;\n\n    const repoMeta = data.repo_metadata || {};\n    \n    // Check for GitHub Sponsors (proxy for oss-wishlist field until available)\n    const has_github_sponsors = repoMeta.has_sponsors || false;\n    \n    const info = {\n      name: data.name,\n      dependents_count: data.dependent_packages_count || 0,\n      stars: repoMeta.stargazers_count || 0,\n      age_months: data.created_at ? this.monthsSince(data.created_at) : 0,\n      last_update_months: data.updated_at ? this.monthsSince(data.updated_at) : 0,\n      repository_url: data.repository_url,\n      big_tech_backing: this.hasBigTechBacking(data.maintainers, repoMeta.owner),\n      has_wishlist: has_github_sponsors  // TODO: Replace with 'oss-wishlist' field when available\n    };\n\n    return info;\n  }\n\n  monthsSince(dateString) {\n    const date = new Date(dateString);\n    const now = new Date();\n    const months = (now.getFullYear() - date.getFullYear()) * CONFIG.MONTHS_PER_YEAR + \n                   (now.getMonth() - date.getMonth());\n    return Math.max(0, months);\n  }\n}\n\n// SBOM Parser\nclass SBOMParser {\n  static async parse(filePath) {\n    try {\n      const content = await fs.readFile(filePath, 'utf8');\n      const sbom = JSON.parse(content);\n\n      if (sbom[CONFIG.SBOM_FORMATS.SPDX_VERSION_KEY]) {\n        return this.parseSPDX(sbom);\n      } else if (sbom[CONFIG.SBOM_FORMATS.CYCLONEDX_FORMAT_KEY] === CONFIG.SBOM_FORMATS.CYCLONEDX_FORMAT_VALUE) {\n        return this.parseCycloneDX(sbom);\n      } else {\n        throw new Error('Unsupported SBOM format. Expected SPDX or CycloneDX JSON.');\n      }\n    } catch (error) {\n      core.setFailed(`Failed to parse SBOM: ${error.message}`);\n      throw error;\n    }\n  }\n\n  static parseSPDX(sbom) {\n    const components = [];\n    \n    if (sbom.packages) {\n      for (const pkg of sbom.packages) {\n        // Skip the root package (the project itself)\n        if (pkg.name && CONFIG.EXCLUDED_PROJECT_NAMES.some(excluded => pkg.name.includes(excluded))) {\n          continue;\n        }\n        \n        if (pkg.externalRefs) {\n          const purlRef = pkg.externalRefs.find(ref => ref.referenceType === CONFIG.PURL_REFERENCE_TYPE);\n          if (purlRef) {\n            const purl = purlRef.referenceLocator;\n            // Skip GitHub Actions and internal tooling, but include all package ecosystems\n            if (purl.startsWith(CONFIG.PURL_PREFIX) && \n                !CONFIG.EXCLUDED_PACKAGE_PATTERNS.some(pattern => purl.includes(pattern))) {\n              components.push({\n                name: pkg.name,\n                version: pkg.versionInfo,\n                purl: purl,\n                supplier: pkg.supplier,\n                license: pkg.licenseConcluded\n              });\n            }\n          }\n        }\n      }\n    }\n\n    return components;\n  }\n\n  static parseCycloneDX(sbom) {\n    const components = [];\n    \n    if (sbom.components) {\n      for (const component of sbom.components) {\n        // Skip GitHub Actions, internal tooling, and root package, but include all package ecosystems\n        if (component.purl && \n            component.purl.startsWith(CONFIG.PURL_PREFIX) && \n            !CONFIG.EXCLUDED_PACKAGE_PATTERNS.some(pattern => component.purl.includes(pattern)) &&\n            !CONFIG.EXCLUDED_PROJECT_NAMES.some(excluded => component.name.includes(excluded))) {\n          components.push({\n            name: component.name,\n            version: component.version,\n            purl: component.purl,\n            supplier: component.supplier?.name,\n            license: component.licenses?.[0]?.license?.id\n          });\n        }\n      }\n    }\n\n    return components;\n  }\n}\n\n// Dependency Analyzer\nclass DependencyAnalyzer {\n  constructor(dependencyThreshold) {\n    this.dependencyThreshold = parseInt(dependencyThreshold) || CONFIG.DEFAULT_DEPENDENCY_THRESHOLD;\n    this.ecosystems = new EcosystemsClient();\n  }\n\n  async analyzeComponents(components) {\n    const results = [];\n\n    core.info(`Analyzing ${components.length} components...`);\n\n    for (const component of components) {\n      if (!component.purl) {\n        core.warning(`Skipping ${component.name}: no PURL available`);\n        continue;\n      }\n\n      core.info(`Analyzing ${component.name}...`);\n      \n      const info = await this.ecosystems.getPackageInfo(component.purl);\n      \n      if (info) {\n        // Only include packages with wishlists (currently GitHub Sponsors as proxy)\n        // TODO: Update to filter on 'oss-wishlist' field when available in ecosyste.ms\n        if (info.has_wishlist) {\n          results.push({\n            ...component,\n            ...info\n          });\n        } else {\n          core.info(`Skipping ${component.name}: no wishlist/GitHub Sponsors`);\n        }\n      } else {\n        core.warning(`No data available for ${component.name}, skipping`);\n      }\n    }\n\n    // Sort by dependents count (highest first) to show impact\n    results.sort((a, b) => b.dependents_count - a.dependents_count);\n\n    return {\n      packages: results,\n      total_analyzed: components.length,\n      with_wishlist_count: results.length\n    };\n  }\n}\n\n// Report Generator\nclass ReportGenerator {\n  static async generateMarkdown(analysis, threshold) {\n    let report = `${CONFIG.REPORT_TITLE}\\n\\n`;\n    \n    report += `> **Note**: This report shows dependencies with **wishlists** (currently using GitHub Sponsors as a proxy until \\`oss-wishlist\\` field is available in ecosyste.ms).\\n\\n`;\n    \n    report += `${CONFIG.REPORT_SUMMARY_TITLE}\\n\\n`;\n    report += `- **Total Dependencies Scanned**: ${analysis.total_analyzed}\\n`;\n    report += `- **Dependencies with Wishlists**: ${analysis.with_wishlist_count}\\n`;\n    \n    const withBigTech = analysis.packages.filter(p => p.big_tech_backing).length;\n    const withoutBigTech = analysis.packages.length - withBigTech;\n    \n    report += `- **With Big Tech Backing**: ${withBigTech}\\n`;\n    report += `- **Without Big Tech Backing**: ${withoutBigTech}\\n\\n`;\n\n    if (analysis.packages.length === 0) {\n      report += `No dependencies found with wishlists/GitHub Sponsors.\\n\\n`;\n      return report;\n    }\n\n    // Group by Big Tech backing\n    const withBacking = analysis.packages.filter(p => p.big_tech_backing);\n    const withoutBacking = analysis.packages.filter(p => !p.big_tech_backing);\n\n    if (withoutBacking.length > 0) {\n      report += `${CONFIG.REPORT_WITHOUT_BACKING_TITLE}\\n\\n`;\n      report += `${CONFIG.REPORT_WITHOUT_BACKING_DESCRIPTION}\\n\\n`;\n      \n      for (const pkg of withoutBacking) {\n        report += `### ${pkg.name} (v${pkg.version})\\n\\n`;\n        report += `- **Dependents**: ${pkg.dependents_count.toLocaleString()} 📦\\n`;\n        report += `- **Stars**: ${pkg.stars.toLocaleString()} ⭐\\n`;\n        report += `- **Age**: ${pkg.age_months} months\\n`;\n        report += `- **Last Update**: ${pkg.last_update_months} months ago\\n`;\n        if (pkg.repository_url) {\n          report += `- **Repository**: ${pkg.repository_url}\\n`;\n        }\n        report += `\\n`;\n      }\n    }\n\n    if (withBacking.length > 0) {\n      report += `${CONFIG.REPORT_WITH_BACKING_TITLE}\\n\\n`;\n      \n      for (const pkg of withBacking) {\n        report += `### ${pkg.name} (v${pkg.version})\\n\\n`;\n        report += `- **Dependents**: ${pkg.dependents_count.toLocaleString()} 📦\\n`;\n        report += `- **Stars**: ${pkg.stars.toLocaleString()} ⭐\\n`;\n        report += `- **Age**: ${pkg.age_months} months\\n`;\n        report += `- **Last Update**: ${pkg.last_update_months} months ago\\n`;\n        if (pkg.repository_url) {\n          report += `- **Repository**: ${pkg.repository_url}\\n`;\n        }\n        report += `\\n`;\n      }\n    }\n\n    report += `---\\n\\n`;\n    report += `${CONFIG.REPORT_FOOTER}\\n`;\n\n    return report;\n  }\n\n  static async saveReport(report, outputPath) {\n    await fs.writeFile(outputPath, report, 'utf8');\n    core.info(`Report saved to ${outputPath}`);\n  }\n}\n\n// Main action logic\nasync function run() {\n  try {\n    const sbomPath = core.getInput('sbom-path');\n    const token = core.getInput('token');\n    const dependencyThreshold = core.getInput('dependency-threshold') || String(CONFIG.DEFAULT_DEPENDENCY_THRESHOLD);\n    const createIssue = core.getInput('create-issue') === 'true';\n    const commentPR = core.getInput('comment-pr') === 'true';\n\n    core.info(`Starting OSS Dependency Analysis...`);\n    core.info(`SBOM Path: ${sbomPath}`);\n    core.info(`Dependency Threshold: ${dependencyThreshold}`);\n\n    const components = await SBOMParser.parse(sbomPath);\n    core.info(`Found ${components.length} components in SBOM`);\n\n    const analyzer = new DependencyAnalyzer(dependencyThreshold);\n    const analysis = await analyzer.analyzeComponents(components);\n\n    const report = await ReportGenerator.generateMarkdown(analysis, parseInt(dependencyThreshold));\n    const reportPath = path.join(process.cwd(), CONFIG.REPORT_FILENAME);\n    await ReportGenerator.saveReport(report, reportPath);\n\n    core.setOutput('with-wishlist-count', analysis.with_wishlist_count);\n    core.setOutput('without-backing-count', analysis.packages.filter(p => !p.big_tech_backing).length);\n    core.setOutput('report-path', reportPath);\n\n    if (commentPR && github.context.payload.pull_request) {\n      const octokit = github.getOctokit(token);\n      await octokit.rest.issues.createComment({\n        ...github.context.repo,\n        issue_number: github.context.payload.pull_request.number,\n        body: report\n      });\n      core.info('Posted analysis as PR comment');\n    }\n\n    const withoutBacking = analysis.packages.filter(p => !p.big_tech_backing).length;\n    if (createIssue && withoutBacking > 0) {\n      const octokit = github.getOctokit(token);\n      await octokit.rest.issues.create({\n        ...github.context.repo,\n        title: `${CONFIG.ISSUE_TITLE_PREFIX} ${withoutBacking} Dependencies with Wishlists Need Support`,\n        body: report,\n        labels: CONFIG.ISSUE_LABELS\n      });\n      core.info('Created issue for dependencies with wishlists needing backing');\n    }\n\n    core.info('✅ Analysis complete!');\n\n  } catch (error) {\n    core.setFailed(error.message);\n  }\n}\n\nrun();"],"names":[],"sourceRoot":""}