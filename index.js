const core = require('@actions/core');
const github = require('@actions/github');
const fs = require('fs').promises;
const path = require('path');

// Configuration Constants
const CONFIG = {
  // Configuration Constants
  API_CONFIGURATION: {
    BASE_URL: 'https://packages.ecosyste.ms/api/v1',
    RATE_LIMIT_DELAY_MS: 100,
    SCORECARD_BASE_URL: 'https://api.securityscorecards.dev/projects'
  },
  
  // Default Thresholds
  DEFAULT_DEPENDENCY_THRESHOLD: 1000,
  
  // Time Constants
  MONTHS_PER_YEAR: 12,
  
  // Output Configuration
  REPORT_FILENAME: 'oss-wishlist-report.md',
  
  // Filtering Patterns
  EXCLUDED_PACKAGE_PATTERNS: ['actions/', 'anchore/'],
  EXCLUDED_PROJECT_NAMES: ['oss-wishlist', 'oss-sustainability'],
  PURL_PREFIX: 'pkg:',
  
  // SBOM Format Identifiers
  SBOM_FORMATS: {
    SPDX_VERSION_KEY: 'spdxVersion',
    CYCLONEDX_FORMAT_KEY: 'bomFormat',
    CYCLONEDX_FORMAT_VALUE: 'CycloneDX'
  },
  
  // PURL Reference Type
  PURL_REFERENCE_TYPE: 'purl',
  
  // GitHub Issue Configuration
  ISSUE_LABELS: ['dependencies', 'sustainability'],
  ISSUE_TITLE_PREFIX: 'âš ï¸',
  
  // Report Configuration
  REPORT_TITLE: '# OSS Dependency Wishlist Report',
  REPORT_SUMMARY_TITLE: '## Summary',
  REPORT_WITHOUT_BACKING_TITLE: '## âš ï¸ Dependencies with Wishlists (no maintainer Big Tech email alias)',
  REPORT_WITHOUT_BACKING_DESCRIPTION: 'These packages have wishlists but no maintainers using Big Tech email aliases:',
  REPORT_WITH_BACKING_TITLE: '## âœ… Dependencies with Wishlists (maintainer Big Tech email alias)',
  REPORT_FOOTER: '*Generated by OSS Wishlist Analyzer*',
  
  // Big Tech Identifiers
  BIG_TECH_DOMAINS: [
    'amazon.com', 'amazon.co.uk',
    'microsoft.com',
    'google.com', 'alphabet.com',
    'meta.com', 'fb.com', 'facebook.com',
    'openai.com',
    'anthropic.com',
    'nvidia.com',
    'netflix.com',
    'apple.com',
    'oracle.com',
    'ibm.com',
    'salesforce.com',
    'intel.com',
    'amd.com'
  ],
  
  BIG_TECH_ORG_NAMES: [
    'facebook', 'meta', 'google', 'microsoft', 'amazon', 
    'netflix', 'apple', 'openai', 'anthropic', 'nvidia',
    'oracle', 'ibm', 'salesforce', 'intel', 'amd'
  ],
  
  // Package Registry Mapping
  REGISTRY_MAP: {
    'npm': 'npmjs.org',
    'pypi': 'pypi.org',
    'cargo': 'crates.io',
    'maven': 'maven.org',
    'gem': 'rubygems.org',
    'golang': 'pkg.go.dev',
    'nuget': 'nuget.org',
    'hex': 'hex.pm',
    'pub': 'pub.dev',
    'composer': 'packagist.org',
    'hackage': 'hackage.haskell.org',
    'cocoapods': 'cocoapods.org',
    'clojars': 'clojars.org',
    'cpan': 'metacpan.org',
    'cran': 'cran.r-project.org',
    'conda': 'anaconda.org'
  }
};

// Mock wishlists loader (temporary until ecosyste.ms exposes official field)
class MockWishlists {
  constructor() {
    this.byPurl = new Map();           // key: purl (lowercased)
    this.byTypeName = new Map();       // key: `${type}:${name}` (lowercased)
    this.byRepoUrl = new Map();        // key: normalized repo URL (lowercased, no .git suffix)
  }

  static normalizeRepoUrl(url) {
    if (!url) return '';
    try {
      let normalized = url.toLowerCase().trim();
      // Remove common prefixes
      normalized = normalized.replace(/^git\+/, '');
      normalized = normalized.replace(/\.git$/, '');
      // Parse URL to normalize
      const u = new URL(normalized);
      // Return canonical form: protocol://host/path (no trailing slash, no .git)
      return `${u.protocol}//${u.host}${u.pathname.replace(/\/$/, '')}`;
    } catch {
      return url.toLowerCase().trim();
    }
  }

  static async load(filePath) {
    const instance = new MockWishlists();
    try {
      const raw = await fs.readFile(filePath, 'utf8');
      const json = JSON.parse(raw);

      const addEntry = (entry, hintKey) => {
        if (!entry || typeof entry !== 'object') return;
        const purl = (entry.purl || '').toLowerCase();
        const hasWishlist = typeof entry.has_wishlist === 'boolean' ? entry.has_wishlist : true;
        const links = Array.isArray(entry.links) ? entry.links.filter(Boolean) :
                      Array.isArray(entry.funding_links) ? entry.funding_links.filter(Boolean) :
                      Array.isArray(entry.wishlist?.links) ? entry.wishlist.links.filter(Boolean) :
                      entry.wishlistUrl ? [entry.wishlistUrl] : [];
        const type = (entry.type || entry.ecosystem || '').toLowerCase();
        const name = (entry.name || entry.projectName || '').toLowerCase();
        const repoUrl = entry.repositoryUrl || entry.repository_url || entry.repo_url || '';
        const details = entry.wishlist && typeof entry.wishlist === 'object' ? entry.wishlist : 
                       entry.projectName ? { projectName: entry.projectName } : undefined;
        const value = { hasWishlist, links, details, __source: 'mock-json' };

        if (purl && purl.startsWith('pkg:')) {
          instance.byPurl.set(purl, value);
        }
        if (type && name) {
          instance.byTypeName.set(`${type}:${name}`, value);
        }
        if (repoUrl) {
          const normalized = MockWishlists.normalizeRepoUrl(repoUrl);
          if (normalized) {
            instance.byRepoUrl.set(normalized, value);
          }
        }

        // Support map-style key hint when entry came from a key/value
        if (!purl && hintKey && hintKey.startsWith('pkg:')) {
          instance.byPurl.set(hintKey.toLowerCase(), value);
        } else if (!type && !name && hintKey && hintKey.includes(':') && !hintKey.startsWith('pkg:')) {
          instance.byTypeName.set(hintKey.toLowerCase(), value);
        }
      };

      if (Array.isArray(json)) {
        for (const entry of json) addEntry(entry);
      } else if (json && typeof json === 'object') {
        const entries = Array.isArray(json.entries) ? json.entries : null;
        if (entries) {
          for (const entry of entries) addEntry(entry);
        } else {
          // Treat as map: key -> value
          for (const [key, value] of Object.entries(json)) {
            if (value && typeof value === 'object') {
              addEntry(value, key);
            } else if (value === true) {
              addEntry({ purl: key, has_wishlist: true }, key);
            }
          }
        }
      }

      core.info(`[MockWishlists] Loaded ${instance.byRepoUrl.size} repository URLs, ${instance.byPurl.size} PURLs, ${instance.byTypeName.size} type:name entries`);
      return instance;
    } catch (e) {
      core.warning(`[MockWishlists] Failed to load from ${filePath}: ${e.message}`);
      return null;
    }
  }

  lookup(purl, parsed, repositoryUrl) {
    if (!purl && !parsed && !repositoryUrl) return null;
    
    // Try exact PURL match first
    const purlKey = (purl || '').toLowerCase();
    if (purlKey && this.byPurl.has(purlKey)) {
      core.info(`[MockWishlists] âœ“ Matched by PURL: ${purl}`);
      return this.byPurl.get(purlKey);
    }
    
    // Try type:name match
    if (parsed && parsed.type && parsed.packageName) {
      const typeName = `${parsed.type.toLowerCase()}:${parsed.packageName.toLowerCase()}`;
      if (this.byTypeName.has(typeName)) {
        core.info(`[MockWishlists] âœ“ Matched by type:name: ${typeName}`);
        return this.byTypeName.get(typeName);
      }
    }
    
    // Try repository URL match
    if (repositoryUrl) {
      const normalized = MockWishlists.normalizeRepoUrl(repositoryUrl);
      if (normalized && this.byRepoUrl.has(normalized)) {
        core.info(`[MockWishlists] âœ“ Matched by repository URL: ${repositoryUrl} â†’ ${normalized}`);
        return this.byRepoUrl.get(normalized);
      }
    }
    
    return null;
  }
}

// Ecosyste.ms API client
class EcosystemsClient {
  constructor(options = {}) {
    this.packagesBaseUrl = CONFIG.API_CONFIGURATION.BASE_URL;
    this.cache = new Map();
    this.scorecardCache = new Map();
    this.bigTechDomains = CONFIG.BIG_TECH_DOMAINS;
    this.registryMap = CONFIG.REGISTRY_MAP;
    this.options = {
      needScorecard: Boolean(options.needScorecard),
      needCriticality: Boolean(options.needCriticality),
      mockWishlists: options.mockWishlists || null
    };
  }

  parsePackageUrl(purl) {
    // Parse PURL format: pkg:type/namespace/name@version
    const purlMatch = purl.match(/^pkg:([^/]+)\/(.+)$/);
    if (!purlMatch) return null;

    const type = purlMatch[1];
    const rest = purlMatch[2];

    // Get registry name from type
    const registry = this.registryMap[type];
    if (!registry) {
      core.info(`Unsupported package type: ${type}`);
      return null;
    }

    // Decode once to correctly handle scoped names like %40scope/name
    const decoded = (() => {
      try { return decodeURIComponent(rest); } catch { return rest; }
    })();

    // Remove trailing @version only if it's after the last '/'
    const lastSlash = decoded.lastIndexOf('/');
    const atIndex = decoded.lastIndexOf('@');
    const namePart = (atIndex > lastSlash) ? decoded.slice(0, atIndex) : decoded;

    const packageName = namePart;
    return { type, registry, packageName };
  }

  async getPackageData(purl) {
    if (this.cache.has(purl)) {
      return this.cache.get(purl);
    }

    try {
      const parsed = this.parsePackageUrl(purl);
      if (!parsed) return null;
      
      const { type, registry, packageName } = parsed;
      
      // URL encode the package name
      const encodedName = encodeURIComponent(packageName);
      const packageUrl = `${this.packagesBaseUrl}/registries/${registry}/packages/${encodedName}`;
      
      core.info(`Fetching ${type} package: ${packageName}`);
      const packageResponse = await fetch(packageUrl);
      
      if (!packageResponse.ok) {
        core.warning(`Package API failed for ${packageName}: ${packageResponse.status}`);
        return null;
      }

      const packageData = await packageResponse.json();
      
      await new Promise(resolve => setTimeout(resolve, CONFIG.API_CONFIGURATION.RATE_LIMIT_DELAY_MS));
      this.cache.set(purl, packageData);
      
      return packageData;
    } catch (error) {
      core.warning(`Error fetching ${purl}: ${error.message}`);
      return null;
    }
  }

  hasBigTechBacking(maintainers, _repoOwner) {
    // Check maintainer emails only (Big Tech email alias)
    if (maintainers && Array.isArray(maintainers)) {
      const hasEmailBacking = maintainers.some(m => {
        if (!m.email) return false;
        const domain = m.email.split('@')[1]?.toLowerCase();
        return this.bigTechDomains.includes(domain);
      });
      if (hasEmailBacking) return true;
    }
    return false;
  }

  extractGitHubRepo(repositoryUrl) {
    if (!repositoryUrl) return null;
    try {
      // Normalize common URL formats
      // Examples: https://github.com/owner/repo, git+https://github.com/owner/repo.git
      let url = repositoryUrl.replace(/^git\+/, '');
      const u = new URL(url);
      if (u.hostname !== 'github.com') return null;
      const parts = u.pathname.replace(/\.git$/, '').split('/').filter(Boolean);
      if (parts.length >= 2) {
        return { owner: parts[0], repo: parts[1] };
      }
      return null;
    } catch {
      return null;
    }
  }

  async getScorecardScore(repositoryUrl) {
    if (!this.options.needScorecard) return null;
    const gh = this.extractGitHubRepo(repositoryUrl);
    if (!gh) return null;
    const key = `${gh.owner}/${gh.repo}`;
    if (this.scorecardCache.has(key)) return this.scorecardCache.get(key);
    try {
      const url = `${CONFIG.API_CONFIGURATION.SCORECARD_BASE_URL}/github.com/${gh.owner}/${gh.repo}`;
      core.info(`Fetching OpenSSF Scorecard for ${key}`);
      const res = await fetch(url);
      if (!res.ok) {
        core.warning(`Scorecard API failed for ${key}: ${res.status}`);
        this.scorecardCache.set(key, null);
        return null;
      }
      const json = await res.json();
      // Top-level score is 0..10
      const score = typeof json.score === 'number' ? json.score : null;
      this.scorecardCache.set(key, score);
      await new Promise(resolve => setTimeout(resolve, CONFIG.API_CONFIGURATION.RATE_LIMIT_DELAY_MS));
      return score;
    } catch (e) {
      core.warning(`Error fetching Scorecard for ${key}: ${e.message}`);
      this.scorecardCache.set(key, null);
      return null;
    }
  }

  async getPackageInfo(purl) {
    const data = await this.getPackageData(purl);
    if (!data) return null;

    const repoMeta = data.repo_metadata || {};
    // Check for wishlist/funding signals (proxy until ecosyste.ms exposes oss-wishlist)
    // Sources we consider:
    // - package-level funding links (data.funding_links)
    // - owner/org sponsors listing (repoMeta.owner_record.metadata.has_sponsors_listing)
    // - owner-level funding links (repoMeta.owner_record.funding_links)
    // - repository FUNDING file presence (repoMeta.metadata.files.funding)
  // - repository-level funding links (repoMeta.funding_links)
  let fundingLinks = Array.isArray(data.funding_links) ? data.funding_links : [];
    const ownerHasSponsors = Boolean(repoMeta.owner_record?.metadata?.has_sponsors_listing);
    const ownerFundingLinks = Array.isArray(repoMeta.owner_record?.funding_links)
      ? repoMeta.owner_record.funding_links
      : [];
    const repoFundingFile = Boolean(repoMeta.metadata?.files?.funding);
  const repoFundingLinks = Array.isArray(repoMeta.funding_links) ? repoMeta.funding_links : [];
    // Some registries might (in future or undocumented) expose maintainer funding_links
    const maintainerFundingLinks = Array.isArray(data.maintainers)
      ? data.maintainers.flatMap(m => Array.isArray(m.funding_links) ? m.funding_links : [])
      : [];
    // Merge and dedupe funding links
    fundingLinks = Array.from(new Set([
      ...fundingLinks,
      ...ownerFundingLinks,
      ...repoFundingLinks,
      ...maintainerFundingLinks
    ].filter(Boolean)));
    let has_github_sponsors = Boolean(
      fundingLinks.length > 0 ||
      ownerHasSponsors ||
      repoFundingFile
    );
    // Mock wishlists override (treat as oss-wishlist presence)
    const parsed = this.parsePackageUrl(purl);
    const repositoryUrl = data.repository_url;
    const mock = this.options.mockWishlists ? this.options.mockWishlists.lookup(purl, parsed, repositoryUrl) : null;
    if (mock) {
      has_github_sponsors = Boolean(mock.hasWishlist);
      if (Array.isArray(mock.links) && mock.links.length) {
        // Merge and dedupe links
        const merged = new Set([...(fundingLinks || []), ...mock.links]);
        fundingLinks = Array.from(merged);
      }
    }
    
    const info = {
      name: data.name,
      dependents_count: data.dependent_packages_count || 0,
      stars: repoMeta.stargazers_count || 0,
      age_months: data.created_at ? this.monthsSince(data.created_at) : 0,
      last_update_months: data.updated_at ? this.monthsSince(data.updated_at) : 0,
      repository_url: data.repository_url,
      big_tech_backing: this.hasBigTechBacking(data.maintainers, repoMeta.owner),
      has_wishlist: has_github_sponsors,  // TODO: Replace with 'oss-wishlist' field when available
      funding_links: fundingLinks,
      scorecard_score: null,
      criticality_score: null
    };

    if (mock) {
      info.wishlist_source = 'mock-json';
      if (mock.details) info.wishlist_details = mock.details;
    }

    // Fetch optional metrics
    if (this.options.needScorecard) {
      info.scorecard_score = await this.getScorecardScore(info.repository_url);
    }
    // Criticality score: currently only include if ecosyste.ms exposes it in known fields
    if (this.options.needCriticality) {
      const criticality = repoMeta?.metadata?.criticality_score ?? data?.criticality_score ?? null;
      if (typeof criticality === 'number') {
        info.criticality_score = criticality;
      } else {
        // If not available, leave null and let filters decide
        info.criticality_score = null;
      }
    }

    return info;
  }

  monthsSince(dateString) {
    const date = new Date(dateString);
    const now = new Date();
    const months = (now.getFullYear() - date.getFullYear()) * CONFIG.MONTHS_PER_YEAR + 
                   (now.getMonth() - date.getMonth());
    return Math.max(0, months);
  }
}

// SBOM Parser
class SBOMParser {
  static async parse(filePath) {
    try {
      const content = await fs.readFile(filePath, 'utf8');
      const sbom = JSON.parse(content);

      if (sbom[CONFIG.SBOM_FORMATS.SPDX_VERSION_KEY]) {
        return this.parseSPDX(sbom);
      } else if (sbom[CONFIG.SBOM_FORMATS.CYCLONEDX_FORMAT_KEY] === CONFIG.SBOM_FORMATS.CYCLONEDX_FORMAT_VALUE) {
        return this.parseCycloneDX(sbom);
      } else {
        throw new Error('Unsupported SBOM format. Expected SPDX or CycloneDX JSON.');
      }
    } catch (error) {
      core.setFailed(`Failed to parse SBOM: ${error.message}`);
      throw error;
    }
  }

  static parseSPDX(sbom) {
    const components = [];
    
    if (sbom.packages) {
      for (const pkg of sbom.packages) {
        // Skip the root package (the project itself)
        if (pkg.name && CONFIG.EXCLUDED_PROJECT_NAMES.some(excluded => pkg.name.includes(excluded))) {
          continue;
        }
        
        if (pkg.externalRefs) {
          const purlRef = pkg.externalRefs.find(ref => ref.referenceType === CONFIG.PURL_REFERENCE_TYPE);
          if (purlRef) {
            const purl = purlRef.referenceLocator;
            // Skip GitHub Actions and internal tooling, but include all package ecosystems
            if (purl.startsWith(CONFIG.PURL_PREFIX) && 
                !CONFIG.EXCLUDED_PACKAGE_PATTERNS.some(pattern => purl.includes(pattern))) {
              components.push({
                name: pkg.name,
                version: pkg.versionInfo,
                purl: purl,
                supplier: pkg.supplier,
                license: pkg.licenseConcluded
              });
            }
          }
        }
      }
    }

    return components;
  }

  static parseCycloneDX(sbom) {
    const components = [];
    
    if (sbom.components) {
      for (const component of sbom.components) {
        // Skip GitHub Actions, internal tooling, and root package, but include all package ecosystems
        if (component.purl && 
            component.purl.startsWith(CONFIG.PURL_PREFIX) && 
            !CONFIG.EXCLUDED_PACKAGE_PATTERNS.some(pattern => component.purl.includes(pattern)) &&
            !CONFIG.EXCLUDED_PROJECT_NAMES.some(excluded => component.name.includes(excluded))) {
          components.push({
            name: component.name,
            version: component.version,
            purl: component.purl,
            supplier: component.supplier?.name,
            license: component.licenses?.[0]?.license?.id
          });
        }
      }
    }

    return components;
  }
}

// Dependency Analyzer
class DependencyAnalyzer {
  constructor(dependencyThreshold, options = {}) {
    this.dependencyThreshold = parseInt(dependencyThreshold) || CONFIG.DEFAULT_DEPENDENCY_THRESHOLD;
    this.options = {
      includeBigTechBacked: Boolean(options.includeBigTechBacked),
      filterScorecard: Boolean(options.filterScorecard),
      scorecardMin: isFinite(parseFloat(options.scorecardMin)) ? parseFloat(options.scorecardMin) : null,
      scorecardMax: isFinite(parseFloat(options.scorecardMax)) ? parseFloat(options.scorecardMax) : null,
      filterCriticality: Boolean(options.filterCriticality),
      criticalityMin: isFinite(parseFloat(options.criticalityMin)) ? parseFloat(options.criticalityMin) : null,
      criticalityMax: isFinite(parseFloat(options.criticalityMax)) ? parseFloat(options.criticalityMax) : null
    };
    this.ecosystems = new EcosystemsClient({
      needScorecard: this.options.filterScorecard,
      needCriticality: this.options.filterCriticality,
      mockWishlists: options.mockWishlists || null
    });
  }

  async analyzeComponents(components) {
    const results = [];
    let countWithRepoMeta = 0;
    let countWithPkgFunding = 0;
    let countOwnerHasSponsors = 0;
    let countRepoFundingSignal = 0;
    let countSkippedNoWishlist = 0;
    let countSkippedBigTechFilter = 0;
    let countSkippedScorecard = 0;
    let countSkippedCriticality = 0;

    core.info(`Analyzing ${components.length} components...`);

    for (const component of components) {
      if (!component.purl) {
        core.warning(`Skipping ${component.name}: no PURL available`);
        continue;
      }

      core.info(`Analyzing ${component.name}...`);
      
      const info = await this.ecosystems.getPackageInfo(component.purl);
      
      if (info) {
        // Basic diagnostics on presence of metadata/funding signals
        if (info.repository_url) countWithRepoMeta++;
        // Only include packages with wishlists (currently GitHub Sponsors as proxy)
        // TODO: Update to filter on 'oss-wishlist' field when available in ecosyste.ms
        if (!info.has_wishlist) {
          core.info(`Skipping ${component.name}: no wishlist/GitHub Sponsors`);
          countSkippedNoWishlist++;
          continue;
        }

        // Big Tech filter: only include Big Tech backed if opted in; otherwise skip those
        if (!this.options.includeBigTechBacked && info.big_tech_backing) {
          core.info(`Skipping ${component.name}: Big Tech backing present and include-bigtech-backed is false`);
          countSkippedBigTechFilter++;
          continue;
        }

        // Scorecard filter (0..10)
        if (this.options.filterScorecard) {
          const s = info.scorecard_score;
          const min = this.options.scorecardMin ?? 0;
          const max = this.options.scorecardMax ?? 10;
          if (typeof s !== 'number' || s < min || s > max) {
            core.info(`Skipping ${component.name}: Scorecard ${s ?? 'N/A'} not in range [${min}, ${max}]`);
            countSkippedScorecard++;
            continue;
          }
        }

        // Criticality filter (0..1)
        if (this.options.filterCriticality) {
          const c = info.criticality_score;
          const min = this.options.criticalityMin ?? 0;
          const max = this.options.criticalityMax ?? 1;
          if (typeof c !== 'number' || c < min || c > max) {
            core.info(`Skipping ${component.name}: Criticality ${c ?? 'N/A'} not in range [${min}, ${max}]`);
            countSkippedCriticality++;
            continue;
          }
        }

        core.info(`Including ${component.name}: passed wishlist and filter criteria`);
        results.push({
          ...component,
          ...info
        });
      } else {
        core.warning(`No data available for ${component.name}, skipping`);
      }
    }

    // Sort by dependents count (highest first) to show impact
    results.sort((a, b) => b.dependents_count - a.dependents_count);

    // High-level diagnostics to aid troubleshooting when zero results
    core.info(`[Diagnostics] With repo metadata: ${countWithRepoMeta}`);
    core.info(`[Diagnostics] Skipped (no wishlist): ${countSkippedNoWishlist}`);
    core.info(`[Diagnostics] Skipped (Big Tech filter): ${countSkippedBigTechFilter}`);
    core.info(`[Diagnostics] Skipped (Scorecard range): ${countSkippedScorecard}`);
    core.info(`[Diagnostics] Skipped (Criticality range): ${countSkippedCriticality}`);

    return {
      packages: results,
      total_analyzed: components.length,
      with_wishlist_count: results.length
    };
  }
}

// Report Generator
class ReportGenerator {
  static async generateMarkdown(analysis, threshold, filters = null) {
      core.info('[ReportGenerator] Starting markdown report generation');
      let report = `${CONFIG.REPORT_TITLE}\n\n`;
      report += `> **Note**: This report shows dependencies with **wishlists** (currently using GitHub Sponsors and other funding signals until the \`oss-wishlist\` field is available in ecosyste.ms).\n\n`;
      if (filters) {
        const bigTechFlag = filters.includeBigTechBacked ? 'on' : 'off';
        const scorecardFlag = filters.filterScorecard ? `on [${filters.scorecardMin ?? '0.0'}, ${filters.scorecardMax ?? '10.0'}]` : 'off';
        const criticalityFlag = filters.filterCriticality ? `on [${filters.criticalityMin ?? '0.0'}, ${filters.criticalityMax ?? '1.0'}]` : 'off';
        const wishlistSourceFlag = filters.useWishlistsJSON ? 'local wishlists JSON override: on' : 'local wishlists JSON override: off';
        report += `> Active filters: Include maintainer Big Tech email alias=${bigTechFlag}; OpenSSF Scorecard=${scorecardFlag}; OpenSSF Criticality=${criticalityFlag}; ${wishlistSourceFlag}\n\n`;
      }
      report += `${CONFIG.REPORT_SUMMARY_TITLE}\n\n`;
      report += `- **Total Dependencies Scanned**: ${analysis.total_analyzed}\n`;
      report += `- **Dependencies with Wishlists**: ${analysis.with_wishlist_count}\n`;
  const withBigTech = analysis.packages.filter(p => p.big_tech_backing).length;
  const withoutBigTech = analysis.packages.length - withBigTech;
  report += `- **Maintainer Big Tech email alias**: ${withBigTech}\n`;
  report += `- **No Maintainer Big Tech email alias**: ${withoutBigTech}\n\n`;
      if (analysis.packages.length === 0) {
        core.warning('[ReportGenerator] No dependencies found with wishlists/GitHub Sponsors');
        report += `No dependencies found with wishlists/GitHub Sponsors.\n\n`;
        return report;
      }
      // Group by Big Tech backing
      const withBacking = analysis.packages.filter(p => p.big_tech_backing);
      const withoutBacking = analysis.packages.filter(p => !p.big_tech_backing);
      core.info(`[ReportGenerator] Packages with backing: ${withBacking.length}, without backing: ${withoutBacking.length}`);
      if (withoutBacking.length > 0) {
        report += `${CONFIG.REPORT_WITHOUT_BACKING_TITLE}\n\n`;
        report += `${CONFIG.REPORT_WITHOUT_BACKING_DESCRIPTION}\n\n`;
        for (const pkg of withoutBacking) {
          core.info(`[ReportGenerator] Adding package without backing: ${pkg.name}@${pkg.version}`);
          report += `### ${pkg.name} (v${pkg.version})\n\n`;
          report += `- **Dependents**: ${pkg.dependents_count.toLocaleString()} ðŸ“¦\n`;
          report += `- **Stars**: ${pkg.stars.toLocaleString()} â­\n`;
          report += `- **Age**: ${pkg.age_months} months\n`;
          report += `- **Last Update**: ${pkg.last_update_months} months ago\n`;
          if (pkg.repository_url) {
            report += `- **Repository**: ${pkg.repository_url}\n`;
          }
          if (typeof pkg.scorecard_score === 'number') {
            report += `- **OpenSSF Scorecard**: ${pkg.scorecard_score.toFixed(1)} / 10\n`;
          }
          if (typeof pkg.criticality_score === 'number') {
            report += `- **OpenSSF Criticality**: ${pkg.criticality_score.toFixed(2)}\n`;
          }
          if (pkg.funding_links && pkg.funding_links.length) {
            report += `- **Funding**:\n`;
            for (const link of pkg.funding_links) {
              report += `  - ${link}\n`;
            }
          }
          if (pkg.wishlist_source === 'mock-json') {
            report += `- **Wishlist source**: mock JSON file\n`;
          }
          report += `\n`;
        }
      }
      if (withBacking.length > 0) {
        report += `${CONFIG.REPORT_WITH_BACKING_TITLE}\n\n`;
        for (const pkg of withBacking) {
          core.info(`[ReportGenerator] Adding package with backing: ${pkg.name}@${pkg.version}`);
          report += `### ${pkg.name} (v${pkg.version})\n\n`;
          report += `- **Dependents**: ${pkg.dependents_count.toLocaleString()} ðŸ“¦\n`;
          report += `- **Stars**: ${pkg.stars.toLocaleString()} â­\n`;
          report += `- **Age**: ${pkg.age_months} months\n`;
          report += `- **Last Update**: ${pkg.last_update_months} months ago\n`;
          if (pkg.repository_url) {
            report += `- **Repository**: ${pkg.repository_url}\n`;
          }
          if (typeof pkg.scorecard_score === 'number') {
            report += `- **OpenSSF Scorecard**: ${pkg.scorecard_score.toFixed(1)} / 10\n`;
          }
          if (typeof pkg.criticality_score === 'number') {
            report += `- **OpenSSF Criticality**: ${pkg.criticality_score.toFixed(2)}\n`;
          }
          if (pkg.funding_links && pkg.funding_links.length) {
            report += `- **Funding**:\n`;
            for (const link of pkg.funding_links) {
              report += `  - ${link}\n`;
            }
          }
          if (pkg.wishlist_source === 'mock-json') {
            report += `- **Wishlist source**: mock JSON file\n`;
          }
          report += `\n`;
        }
      }
      report += `---\n\n`;
    report += `${CONFIG.REPORT_FOOTER}\n`;
      core.info('[ReportGenerator] Markdown report generation complete');
      return report;
  }

  static async saveReport(report, outputPath) {
    await fs.writeFile(outputPath, report, 'utf8');
    core.info(`Report saved to ${outputPath}`);
  }
}

// Main action logic
async function run() {
  try {
    core.info('[Action] Starting OSS Dependency Analysis...');
    const sbomPath = core.getInput('sbom-path');
    core.info(`[Action] SBOM Path: ${sbomPath}`);
    const token = core.getInput('token');
    const dependencyThreshold = core.getInput('dependency-threshold') || String(CONFIG.DEFAULT_DEPENDENCY_THRESHOLD);
    core.info(`[Action] Dependency Threshold: ${dependencyThreshold}`);
    const createIssue = core.getInput('create-issue') === 'true';
    core.info(`[Action] Create Issue: ${createIssue}`);
    const commentPR = core.getInput('comment-pr') === 'true';
    core.info(`[Action] Comment PR: ${commentPR}`);
    // New optional filters
    const includeBigTechBacked = core.getInput('include-bigtech-backed') === 'true';
    const filterScorecard = core.getInput('filter-scorecard') === 'true';
    const scorecardMin = core.getInput('scorecard-min');
    const scorecardMax = core.getInput('scorecard-max');
    const filterCriticality = core.getInput('filter-criticality') === 'true';
    const criticalityMin = core.getInput('criticality-min');
    const criticalityMax = core.getInput('criticality-max');
    // Wishlist JSON controls (new) + legacy fallbacks
    const useWishlistsJSON = core.getInput('use-wishlists-json') === 'true';
    const wishlistsPath = core.getInput('wishlists-path') || 'wishlists.json';
    const mockWishlistsPathInput = core.getInput('mock-wishlists-path') || '';
    const wishlistMapPathLegacy = core.getInput('wishlist-map-path') || '';
    core.info(`[Action] include-bigtech-backed: ${includeBigTechBacked}`);
    core.info(`[Action] filter-scorecard: ${filterScorecard} [${scorecardMin}, ${scorecardMax}]`);
    core.info(`[Action] filter-criticality: ${filterCriticality} [${criticalityMin}, ${criticalityMax}]`);
    core.info(`[Action] use-wishlists-json: ${useWishlistsJSON}`);
    core.info(`[Action] wishlists-path: ${wishlistsPath}`);
    core.info(`[Action] mock-wishlists-path (legacy): ${mockWishlistsPathInput || '(none)'}`);
    core.info(`[Action] wishlist-map-path (legacy): ${wishlistMapPathLegacy || '(none)'}`);

    // Load mock wishlists file if provided
    let mockWishlists = null;
    // Load wishlists JSON if selected or legacy path provided
    let selectedWishlistPath = '';
    if (useWishlistsJSON) {
      selectedWishlistPath = wishlistsPath;
    } else if (mockWishlistsPathInput) {
      selectedWishlistPath = mockWishlistsPathInput;
    } else if (wishlistMapPathLegacy) {
      selectedWishlistPath = wishlistMapPathLegacy;
    }
    if (selectedWishlistPath) {
      try {
        const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
        const resolvedMockPath = path.isAbsolute(selectedWishlistPath)
          ? selectedWishlistPath
          : path.join(workspace, selectedWishlistPath);
        core.info(`[Action] Loading wishlists JSON from ${resolvedMockPath}`);
        mockWishlists = await MockWishlists.load(resolvedMockPath);
        if (!mockWishlists) {
          core.warning('[Action] Wishlists JSON file could not be loaded; proceeding without it.');
        }
      } catch (e) {
        core.warning(`[Action] Failed to initialize wishlists JSON: ${e.message}`);
      }
    }

    let components;
    try {
      components = await SBOMParser.parse(sbomPath);
      core.info(`[Action] Found ${components.length} components in SBOM`);
    } catch (err) {
      core.error(`[Action] SBOM parsing failed: ${err.message}`);
      throw err;
    }

    let analysis;
    try {
      const analyzer = new DependencyAnalyzer(dependencyThreshold, {
        includeBigTechBacked,
        filterScorecard,
        scorecardMin,
        scorecardMax,
        filterCriticality,
        criticalityMin,
        criticalityMax,
        mockWishlists
      });
      analysis = await analyzer.analyzeComponents(components);
      core.info(`[Action] Dependency analysis complete. Total packages: ${analysis.packages.length}`);
    } catch (err) {
      core.error(`[Action] Dependency analysis failed: ${err.message}`);
      throw err;
    }

    let report;
    try {
      report = await ReportGenerator.generateMarkdown(analysis, parseInt(dependencyThreshold), {
        includeBigTechBacked,
        filterScorecard,
        scorecardMin,
        scorecardMax,
        filterCriticality,
        criticalityMin,
        criticalityMax,
        useWishlistsJSON: Boolean(mockWishlists)
      });
      core.info('[Action] Report markdown generated');
    } catch (err) {
      core.error(`[Action] Report generation failed: ${err.message}`);
      throw err;
    }

    const reportPath = path.join(process.cwd(), CONFIG.REPORT_FILENAME);
    try {
      await ReportGenerator.saveReport(report, reportPath);
      core.info(`[Action] Report saved to ${reportPath}`);
    } catch (err) {
      core.error(`[Action] Failed to save report: ${err.message}`);
      throw err;
    }

    core.setOutput('with-wishlist-count', analysis.with_wishlist_count);
    core.setOutput('without-backing-count', analysis.packages.filter(p => !p.big_tech_backing).length);
    core.setOutput('report-path', reportPath);

    if (commentPR && github.context.payload.pull_request) {
      try {
        const octokit = github.getOctokit(token);
        await octokit.rest.issues.createComment({
          ...github.context.repo,
          issue_number: github.context.payload.pull_request.number,
          body: report
        });
        core.info('[Action] Posted analysis as PR comment');
      } catch (err) {
        core.error(`[Action] Failed to post PR comment: ${err.message}`);
      }
    }

    const withoutBacking = analysis.packages.filter(p => !p.big_tech_backing).length;
    if (createIssue && withoutBacking > 0) {
      try {
        const octokit = github.getOctokit(token);
        await octokit.rest.issues.create({
          ...github.context.repo,
          title: `${CONFIG.ISSUE_TITLE_PREFIX} ${withoutBacking} Dependencies with Wishlists Need Support`,
          body: report,
          labels: CONFIG.ISSUE_LABELS
        });
        core.info('[Action] Created issue for dependencies with wishlists needing backing');
      } catch (err) {
        core.error(`[Action] Failed to create issue: ${err.message}`);
      }
    }

    core.info('[Action] âœ… Analysis complete!');
  } catch (error) {
    core.error(`[Action] Failed: ${error.message}`);
    core.setFailed(error.message);
  }
}

run();