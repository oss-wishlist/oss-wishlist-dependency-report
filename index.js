const core = require('@actions/core');
const github = require('@actions/github');
const fs = require('fs').promises;
const path = require('path');

// Configuration Constants
const CONFIG = {
  // Configuration Constants
  API_CONFIGURATION: {
    BASE_URL: 'https://packages.ecosyste.ms/api/v1',
    RATE_LIMIT_DELAY_MS: 100,
  },
  
  // Default Thresholds
  DEFAULT_DEPENDENCY_THRESHOLD: 1000,
  
  // Time Constants
  MONTHS_PER_YEAR: 12,
  
  // Output Configuration
  REPORT_FILENAME: 'oss-wishlist-report.md',
  
  // Filtering Patterns
  EXCLUDED_PACKAGE_PATTERNS: ['actions/', 'anchore/'],
  EXCLUDED_PROJECT_NAMES: ['oss-wishlist', 'oss-sustainability'],
  PURL_PREFIX: 'pkg:',
  
  // SBOM Format Identifiers
  SBOM_FORMATS: {
    SPDX_VERSION_KEY: 'spdxVersion',
    CYCLONEDX_FORMAT_KEY: 'bomFormat',
    CYCLONEDX_FORMAT_VALUE: 'CycloneDX'
  },
  
  // PURL Reference Type
  PURL_REFERENCE_TYPE: 'purl',
  
  // GitHub Issue Configuration
  ISSUE_LABELS: ['dependencies', 'sustainability'],
  ISSUE_TITLE_PREFIX: '⚠️',
  
  // Report Configuration
  REPORT_TITLE: '# OSS Dependency Wishlist Report',
  REPORT_SUMMARY_TITLE: '## Summary',
  REPORT_WITHOUT_BACKING_TITLE: '## ⚠️ Dependencies with Wishlists Needing Support',
  REPORT_WITHOUT_BACKING_DESCRIPTION: 'These packages have wishlists but may lack organizational support:',
  REPORT_WITH_BACKING_TITLE: '## ✅ Dependencies with Wishlists and Big Tech Backing',
  REPORT_FOOTER: '*Generated by OSS Wishlist Analyzer*',
  
  // Big Tech Identifiers
  BIG_TECH_DOMAINS: [
    'amazon.com', 'amazon.co.uk',
    'microsoft.com',
    'google.com', 'alphabet.com',
    'meta.com', 'fb.com', 'facebook.com',
    'openai.com',
    'anthropic.com',
    'nvidia.com',
    'netflix.com',
    'apple.com',
    'oracle.com',
    'ibm.com',
    'salesforce.com',
    'intel.com',
    'amd.com'
  ],
  
  BIG_TECH_ORG_NAMES: [
    'facebook', 'meta', 'google', 'microsoft', 'amazon', 
    'netflix', 'apple', 'openai', 'anthropic', 'nvidia',
    'oracle', 'ibm', 'salesforce', 'intel', 'amd'
  ],
  
  // Package Registry Mapping
  REGISTRY_MAP: {
    'npm': 'npmjs.org',
    'pypi': 'pypi.org',
    'cargo': 'crates.io',
    'maven': 'maven.org',
    'gem': 'rubygems.org',
    'golang': 'pkg.go.dev',
    'nuget': 'nuget.org',
    'hex': 'hex.pm',
    'pub': 'pub.dev',
    'composer': 'packagist.org',
    'hackage': 'hackage.haskell.org',
    'cocoapods': 'cocoapods.org',
    'clojars': 'clojars.org',
    'cpan': 'metacpan.org',
    'cran': 'cran.r-project.org',
    'conda': 'anaconda.org'
  }
};

// Ecosyste.ms API client
class EcosystemsClient {
  constructor() {
    this.packagesBaseUrl = CONFIG.API_CONFIGURATION.BASE_URL;
    this.cache = new Map();
    this.bigTechDomains = CONFIG.BIG_TECH_DOMAINS;
    this.registryMap = CONFIG.REGISTRY_MAP;
  }

  parsePackageUrl(purl) {
    // Parse PURL format: pkg:type/namespace/name@version
    const purlMatch = purl.match(/^pkg:([^/]+)\/(.+)$/);
    if (!purlMatch) return null;

    const type = purlMatch[1];
    const rest = purlMatch[2];

    // Get registry name from type
    const registry = this.registryMap[type];
    if (!registry) {
      core.info(`Unsupported package type: ${type}`);
      return null;
    }

    // Decode once to correctly handle scoped names like %40scope/name
    const decoded = (() => {
      try { return decodeURIComponent(rest); } catch { return rest; }
    })();

    // Remove trailing @version only if it's after the last '/'
    const lastSlash = decoded.lastIndexOf('/');
    const atIndex = decoded.lastIndexOf('@');
    const namePart = (atIndex > lastSlash) ? decoded.slice(0, atIndex) : decoded;

    const packageName = namePart;
    return { type, registry, packageName };
  }

  async getPackageData(purl) {
    if (this.cache.has(purl)) {
      return this.cache.get(purl);
    }

    try {
      const parsed = this.parsePackageUrl(purl);
      if (!parsed) return null;
      
      const { type, registry, packageName } = parsed;
      
      // URL encode the package name
      const encodedName = encodeURIComponent(packageName);
      const packageUrl = `${this.packagesBaseUrl}/registries/${registry}/packages/${encodedName}`;
      
      core.info(`Fetching ${type} package: ${packageName}`);
      const packageResponse = await fetch(packageUrl);
      
      if (!packageResponse.ok) {
        core.warning(`Package API failed for ${packageName}: ${packageResponse.status}`);
        return null;
      }

      const packageData = await packageResponse.json();
      
      await new Promise(resolve => setTimeout(resolve, CONFIG.API_CONFIGURATION.RATE_LIMIT_DELAY_MS));
      this.cache.set(purl, packageData);
      
      return packageData;
    } catch (error) {
      core.warning(`Error fetching ${purl}: ${error.message}`);
      return null;
    }
  }

  hasBigTechBacking(maintainers, repoOwner) {
    // Check maintainer emails
    if (maintainers && Array.isArray(maintainers)) {
      const hasEmailBacking = maintainers.some(m => {
        if (!m.email) return false;
        const domain = m.email.split('@')[1]?.toLowerCase();
        return this.bigTechDomains.includes(domain);
      });
      if (hasEmailBacking) return true;
    }
    
    // Check repo owner
    if (repoOwner) {
      const ownerLower = repoOwner.toLowerCase();
      return CONFIG.BIG_TECH_ORG_NAMES.some(org => ownerLower.includes(org));
    }
    
    return false;
  }

  async getPackageInfo(purl) {
    const data = await this.getPackageData(purl);
    if (!data) return null;

    const repoMeta = data.repo_metadata || {};
    // Check for wishlist/funding signals (proxy until ecosyste.ms exposes oss-wishlist)
    // Sources we consider:
    // - package-level funding links (data.funding_links)
    // - owner/org sponsors listing (repoMeta.owner_record.metadata.has_sponsors_listing)
    // - owner-level funding links (repoMeta.owner_record.funding_links)
    // - repository FUNDING file presence (repoMeta.metadata.files.funding)
    // - repository-level funding links (repoMeta.funding_links)
    const pkgFundingLinks = Array.isArray(data.funding_links) ? data.funding_links : [];
    const ownerHasSponsors = Boolean(repoMeta.owner_record?.metadata?.has_sponsors_listing);
    const ownerFundingLinks = Array.isArray(repoMeta.owner_record?.funding_links)
      ? repoMeta.owner_record.funding_links
      : [];
    const repoFundingFile = Boolean(repoMeta.metadata?.files?.funding);
    const repoFundingLinks = Array.isArray(repoMeta.funding_links) ? repoMeta.funding_links : [];
    // Some registries might (in future or undocumented) expose maintainer funding_links
    const maintainerFundingLinks = Array.isArray(data.maintainers)
      ? data.maintainers.flatMap(m => Array.isArray(m.funding_links) ? m.funding_links : [])
      : [];
    // Merge and dedupe funding links
    const fundingLinks = Array.from(new Set([
      ...pkgFundingLinks,
      ...ownerFundingLinks,
      ...repoFundingLinks,
      ...maintainerFundingLinks
    ].filter(Boolean)));
    const has_github_sponsors = Boolean(
      fundingLinks.length > 0 ||
      ownerHasSponsors ||
      repoFundingFile
    );
    
    const info = {
      name: data.name,
      dependents_count: data.dependent_packages_count || 0,
      stars: repoMeta.stargazers_count || 0,
      age_months: data.created_at ? this.monthsSince(data.created_at) : 0,
      last_update_months: data.updated_at ? this.monthsSince(data.updated_at) : 0,
      repository_url: data.repository_url,
      big_tech_backing: this.hasBigTechBacking(data.maintainers, repoMeta.owner),
      has_wishlist: has_github_sponsors,  // TODO: Replace with 'oss-wishlist' field when available
      funding_links: fundingLinks
    };

    return info;
  }

  monthsSince(dateString) {
    const date = new Date(dateString);
    const now = new Date();
    const months = (now.getFullYear() - date.getFullYear()) * CONFIG.MONTHS_PER_YEAR + 
                   (now.getMonth() - date.getMonth());
    return Math.max(0, months);
  }
}

// SBOM Parser
class SBOMParser {
  static async parse(filePath) {
    try {
      const content = await fs.readFile(filePath, 'utf8');
      const sbom = JSON.parse(content);

      if (sbom[CONFIG.SBOM_FORMATS.SPDX_VERSION_KEY]) {
        return this.parseSPDX(sbom);
      } else if (sbom[CONFIG.SBOM_FORMATS.CYCLONEDX_FORMAT_KEY] === CONFIG.SBOM_FORMATS.CYCLONEDX_FORMAT_VALUE) {
        return this.parseCycloneDX(sbom);
      } else {
        throw new Error('Unsupported SBOM format. Expected SPDX or CycloneDX JSON.');
      }
    } catch (error) {
      core.setFailed(`Failed to parse SBOM: ${error.message}`);
      throw error;
    }
  }

  static parseSPDX(sbom) {
    const components = [];
    
    if (sbom.packages) {
      for (const pkg of sbom.packages) {
        // Skip the root package (the project itself)
        if (pkg.name && CONFIG.EXCLUDED_PROJECT_NAMES.some(excluded => pkg.name.includes(excluded))) {
          continue;
        }
        
        if (pkg.externalRefs) {
          const purlRef = pkg.externalRefs.find(ref => ref.referenceType === CONFIG.PURL_REFERENCE_TYPE);
          if (purlRef) {
            const purl = purlRef.referenceLocator;
            // Skip GitHub Actions and internal tooling, but include all package ecosystems
            if (purl.startsWith(CONFIG.PURL_PREFIX) && 
                !CONFIG.EXCLUDED_PACKAGE_PATTERNS.some(pattern => purl.includes(pattern))) {
              components.push({
                name: pkg.name,
                version: pkg.versionInfo,
                purl: purl,
                supplier: pkg.supplier,
                license: pkg.licenseConcluded
              });
            }
          }
        }
      }
    }

    return components;
  }

  static parseCycloneDX(sbom) {
    const components = [];
    
    if (sbom.components) {
      for (const component of sbom.components) {
        // Skip GitHub Actions, internal tooling, and root package, but include all package ecosystems
        if (component.purl && 
            component.purl.startsWith(CONFIG.PURL_PREFIX) && 
            !CONFIG.EXCLUDED_PACKAGE_PATTERNS.some(pattern => component.purl.includes(pattern)) &&
            !CONFIG.EXCLUDED_PROJECT_NAMES.some(excluded => component.name.includes(excluded))) {
          components.push({
            name: component.name,
            version: component.version,
            purl: component.purl,
            supplier: component.supplier?.name,
            license: component.licenses?.[0]?.license?.id
          });
        }
      }
    }

    return components;
  }
}

// Dependency Analyzer
class DependencyAnalyzer {
  constructor(dependencyThreshold) {
    this.dependencyThreshold = parseInt(dependencyThreshold) || CONFIG.DEFAULT_DEPENDENCY_THRESHOLD;
    this.ecosystems = new EcosystemsClient();
  }

  async analyzeComponents(components) {
    const results = [];
    let countWithRepoMeta = 0;
    let countWithPkgFunding = 0;
    let countOwnerHasSponsors = 0;
    let countRepoFundingSignal = 0;
    let countSkippedNoWishlist = 0;

    core.info(`Analyzing ${components.length} components...`);

    for (const component of components) {
      if (!component.purl) {
        core.warning(`Skipping ${component.name}: no PURL available`);
        continue;
      }

      core.info(`Analyzing ${component.name}...`);
      
      const info = await this.ecosystems.getPackageInfo(component.purl);
      
      if (info) {
        // Basic diagnostics on presence of metadata/funding signals
        if (info.repository_url) countWithRepoMeta++;
        // Only include packages with wishlists (currently GitHub Sponsors as proxy)
        // TODO: Update to filter on 'oss-wishlist' field when available in ecosyste.ms
        if (info.has_wishlist) {
          core.info(`Including ${component.name}: wishlist/funding detected`);
          results.push({
            ...component,
            ...info
          });
        } else {
          core.info(`Skipping ${component.name}: no wishlist/GitHub Sponsors`);
          countSkippedNoWishlist++;
        }
      } else {
        core.warning(`No data available for ${component.name}, skipping`);
      }
    }

    // Sort by dependents count (highest first) to show impact
    results.sort((a, b) => b.dependents_count - a.dependents_count);

    // High-level diagnostics to aid troubleshooting when zero results
    core.info(`[Diagnostics] With repo metadata: ${countWithRepoMeta}`);
    core.info(`[Diagnostics] Skipped (no wishlist): ${countSkippedNoWishlist}`);

    return {
      packages: results,
      total_analyzed: components.length,
      with_wishlist_count: results.length
    };
  }
}

// Report Generator
class ReportGenerator {
  static async generateMarkdown(analysis, threshold) {
      core.info('[ReportGenerator] Starting markdown report generation');
      let report = `${CONFIG.REPORT_TITLE}\n\n`;
      report += `> **Note**: This report shows dependencies with **wishlists** (currently using GitHub Sponsors as a proxy until \`oss-wishlist\` field is available in ecosyste.ms).\n\n`;
      report += `${CONFIG.REPORT_SUMMARY_TITLE}\n\n`;
      report += `- **Total Dependencies Scanned**: ${analysis.total_analyzed}\n`;
      report += `- **Dependencies with Wishlists**: ${analysis.with_wishlist_count}\n`;
      const withBigTech = analysis.packages.filter(p => p.big_tech_backing).length;
      const withoutBigTech = analysis.packages.length - withBigTech;
      report += `- **With Big Tech Backing**: ${withBigTech}\n`;
      report += `- **Without Big Tech Backing**: ${withoutBigTech}\n\n`;
      if (analysis.packages.length === 0) {
        core.warning('[ReportGenerator] No dependencies found with wishlists/GitHub Sponsors');
        report += `No dependencies found with wishlists/GitHub Sponsors.\n\n`;
        return report;
      }
      // Group by Big Tech backing
      const withBacking = analysis.packages.filter(p => p.big_tech_backing);
      const withoutBacking = analysis.packages.filter(p => !p.big_tech_backing);
      core.info(`[ReportGenerator] Packages with backing: ${withBacking.length}, without backing: ${withoutBacking.length}`);
      if (withoutBacking.length > 0) {
        report += `${CONFIG.REPORT_WITHOUT_BACKING_TITLE}\n\n`;
        report += `${CONFIG.REPORT_WITHOUT_BACKING_DESCRIPTION}\n\n`;
        for (const pkg of withoutBacking) {
          core.info(`[ReportGenerator] Adding package without backing: ${pkg.name}@${pkg.version}`);
          report += `### ${pkg.name} (v${pkg.version})\n\n`;
          report += `- **Dependents**: ${pkg.dependents_count.toLocaleString()} 📦\n`;
          report += `- **Stars**: ${pkg.stars.toLocaleString()} ⭐\n`;
          report += `- **Age**: ${pkg.age_months} months\n`;
          report += `- **Last Update**: ${pkg.last_update_months} months ago\n`;
          if (pkg.repository_url) {
            report += `- **Repository**: ${pkg.repository_url}\n`;
          }
          if (pkg.funding_links && pkg.funding_links.length) {
            report += `- **Funding**:\n`;
            for (const link of pkg.funding_links) {
              report += `  - ${link}\n`;
            }
          }
          report += `\n`;
        }
      }
      if (withBacking.length > 0) {
        report += `${CONFIG.REPORT_WITH_BACKING_TITLE}\n\n`;
        for (const pkg of withBacking) {
          core.info(`[ReportGenerator] Adding package with backing: ${pkg.name}@${pkg.version}`);
          report += `### ${pkg.name} (v${pkg.version})\n\n`;
          report += `- **Dependents**: ${pkg.dependents_count.toLocaleString()} 📦\n`;
          report += `- **Stars**: ${pkg.stars.toLocaleString()} ⭐\n`;
          report += `- **Age**: ${pkg.age_months} months\n`;
          report += `- **Last Update**: ${pkg.last_update_months} months ago\n`;
          if (pkg.repository_url) {
            report += `- **Repository**: ${pkg.repository_url}\n`;
          }
          if (pkg.funding_links && pkg.funding_links.length) {
            report += `- **Funding**:\n`;
            for (const link of pkg.funding_links) {
              report += `  - ${link}\n`;
            }
          }
          report += `\n`;
        }
      }
      report += `---\n\n`;
      report += `${CONFIG.REPORT_FOOTER}\n`;
      core.info('[ReportGenerator] Markdown report generation complete');
      return report;
  }

  static async saveReport(report, outputPath) {
    await fs.writeFile(outputPath, report, 'utf8');
    core.info(`Report saved to ${outputPath}`);
  }
}

// Main action logic
async function run() {
  try {
    core.info('[Action] Starting OSS Dependency Analysis...');
    const sbomPath = core.getInput('sbom-path');
    core.info(`[Action] SBOM Path: ${sbomPath}`);
    const token = core.getInput('token');
    const dependencyThreshold = core.getInput('dependency-threshold') || String(CONFIG.DEFAULT_DEPENDENCY_THRESHOLD);
    core.info(`[Action] Dependency Threshold: ${dependencyThreshold}`);
    const createIssue = core.getInput('create-issue') === 'true';
    core.info(`[Action] Create Issue: ${createIssue}`);
    const commentPR = core.getInput('comment-pr') === 'true';
    core.info(`[Action] Comment PR: ${commentPR}`);

    let components;
    try {
      components = await SBOMParser.parse(sbomPath);
      core.info(`[Action] Found ${components.length} components in SBOM`);
    } catch (err) {
      core.error(`[Action] SBOM parsing failed: ${err.message}`);
      throw err;
    }

    let analysis;
    try {
      const analyzer = new DependencyAnalyzer(dependencyThreshold);
      analysis = await analyzer.analyzeComponents(components);
      core.info(`[Action] Dependency analysis complete. Total packages: ${analysis.packages.length}`);
    } catch (err) {
      core.error(`[Action] Dependency analysis failed: ${err.message}`);
      throw err;
    }

    let report;
    try {
      report = await ReportGenerator.generateMarkdown(analysis, parseInt(dependencyThreshold));
      core.info('[Action] Report markdown generated');
    } catch (err) {
      core.error(`[Action] Report generation failed: ${err.message}`);
      throw err;
    }

    const reportPath = path.join(process.cwd(), CONFIG.REPORT_FILENAME);
    try {
      await ReportGenerator.saveReport(report, reportPath);
      core.info(`[Action] Report saved to ${reportPath}`);
    } catch (err) {
      core.error(`[Action] Failed to save report: ${err.message}`);
      throw err;
    }

    core.setOutput('with-wishlist-count', analysis.with_wishlist_count);
    core.setOutput('without-backing-count', analysis.packages.filter(p => !p.big_tech_backing).length);
    core.setOutput('report-path', reportPath);

    if (commentPR && github.context.payload.pull_request) {
      try {
        const octokit = github.getOctokit(token);
        await octokit.rest.issues.createComment({
          ...github.context.repo,
          issue_number: github.context.payload.pull_request.number,
          body: report
        });
        core.info('[Action] Posted analysis as PR comment');
      } catch (err) {
        core.error(`[Action] Failed to post PR comment: ${err.message}`);
      }
    }

    const withoutBacking = analysis.packages.filter(p => !p.big_tech_backing).length;
    if (createIssue && withoutBacking > 0) {
      try {
        const octokit = github.getOctokit(token);
        await octokit.rest.issues.create({
          ...github.context.repo,
          title: `${CONFIG.ISSUE_TITLE_PREFIX} ${withoutBacking} Dependencies with Wishlists Need Support`,
          body: report,
          labels: CONFIG.ISSUE_LABELS
        });
        core.info('[Action] Created issue for dependencies with wishlists needing backing');
      } catch (err) {
        core.error(`[Action] Failed to create issue: ${err.message}`);
      }
    }

    core.info('[Action] ✅ Analysis complete!');
  } catch (error) {
    core.error(`[Action] Failed: ${error.message}`);
    core.setFailed(error.message);
  }
}

run();